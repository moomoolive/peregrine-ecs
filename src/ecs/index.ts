import {
    Table
} from "../table/index"
import {
    EntityRecords
} from "../entities/index"
import {
    componentRegistryMacro,
    ComponentRegistry,
} from "../dataStructures/registries/index"
import {
    ComponentsDeclaration,
    ComponentClasses,
    generateComponentClasses,
} from "../components/index"
import {Debugger} from "./debugger"
import {EntityMutator} from "../entities/mutator"
import {SharedInt32Array} from "../dataStructures/sharedArrays"
import {Entities, Bytes} from "../consts"
import {Allocator, createComponentAllocator} from "../allocator/index"

export class BaseEcs<
    Components extends ComponentsDeclaration
> {
    /** entity ids that were recycled or not used yet */
    protected _unusedEntityIds: Int32Array
    /** which archetype and row an entity resides in */
    protected _entityRecords: EntityRecords
    /** a table holds entities that have the exact same components */
    protected _tables: Table[]
    protected "&tableIndexes": Int32Array
    protected _componentAllocator: Allocator

    /* generated by macros */
    protected readonly _componentClasses: ComponentClasses
    readonly components: ComponentRegistry<Components>
    /* ends here */

    readonly debugger: Debugger
    private _mutator: EntityMutator<Components>

    constructor(params: {
        componentClasses: ComponentClasses,
        componentRegistry: ComponentRegistry<Components>
        maxEntities: number,
        allocatorInitialMemoryMB: number
    }) {
        const {
            componentClasses,
            componentRegistry,
            maxEntities,
            allocatorInitialMemoryMB
        } = params
        
        this._unusedEntityIds = SharedInt32Array(maxEntities)
        this["&tableIndexes"] = SharedInt32Array(5_000)
        this._entityRecords = new EntityRecords(maxEntities)
        this._tables = []
        this._componentAllocator = createComponentAllocator(
            Bytes.per_megabytes * allocatorInitialMemoryMB, 
            false
        )

        /* generated via macros */
        this.components = componentRegistry
        this._componentClasses = componentClasses
        /* ends here */

        this.debugger = new Debugger(
            this._componentClasses
        )
        this._mutator = new EntityMutator<Components>(
            this._entityRecords,
            this._tables
        )
    }
}

export interface EcsClass<
    Components extends ComponentsDeclaration
> {
    new(): BaseEcs<Components>
}

export function defineEcs<
    T extends ComponentsDeclaration
>(params: {
    readonly components: T
    maxEntities?: number,
    allocatorInitialMemoryMB?: number
}): EcsClass<T> {
    const {
        components: componentDeclaration,
        maxEntities = Entities.limit,
        allocatorInitialMemoryMB = 50
    } = params
    const componentClasses = generateComponentClasses(componentDeclaration)
    const componentRegistry = componentRegistryMacro(componentDeclaration)
    return Function(`return (
        BaseEcs, componentClasses, componentRegistry,
        Debugger, EntityMutator, maxEntities,
        allocatorInitialMemoryMB,
    ) => {
    return class GeneratedEcs extends BaseEcs {
        constructor() {
            super({
                componentClasses,
                maxEntities,
                componentRegistry,
                allocatorInitialMemoryMB
            })
        }
    }
}`)()(
        BaseEcs, componentClasses, componentRegistry,
        Debugger, EntityMutator, maxEntities,
        allocatorInitialMemoryMB
    )
}
